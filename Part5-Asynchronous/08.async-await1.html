<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Async/Await 1</title>
</head>

<body>
    <script>
        /*
        Async/Await:
        This concept is common in other programming languages

        > Synchronous code runs in sequence. 
          - only one task are being executed at a time
          - each operation must wait for the previous one to complete before executing. 
        > Asynchronous code runs in parallel. 
          - multiple tasks can be executed at a time
          - an operation can occur while another one is still being processed.

        Asynchronous programming is a technique that enables your program 
        to start a potentially long-running task and still be able 
        to be responsive to other events while that task runs, 
        rather than having to wait until that task has finished. 
        Once that task has finished, your program is presented with the result.

        Async/Await is just a syntactic sugar* of using Promises in JavaScript

        Promises can still add more heavy code or long lines of codes to our application 
        
        - async and await make promises easier to write"
        - async makes a function return a Promise
        - await makes a function wait for a Promise

        * Syntactic sugar is a term for a more concise syntax 
        that provides the same functionality for something that already exists.
        */


        // Starting with the very basic:
        // Instead of going with new Promises and .then() and ... we can just use the keyword "async"
        // Below is just a normal basic function
        function checkNumber(x) {
            return x % 2 == 0 ? "Even" : "Odd";
        }
        console.log(checkNumber(8)); // Even

        // As async/await are just a Syntactic sugar of using Promises 
        // so we can simply add the keyword "async" before the function
        async function checkValue(x) {
            return x % 2 == 0 ? "Even" : "Odd";
        }
        console.log(checkValue(8)); // Promise {<fulfilled>: 'Even'}

        // So async/await work with any function: with names, anonymous, arrow functions

        /*
        Now since checkValue() returns a promise, we have learnt that consuming any returned value 
        when the promise is fulfilled can be done can be done using .then()
        */
        checkValue(8).then(response => console.log(response)); // Even

        // The keyword "await" only works inside "async" function

        // Another example to review based on our first code of using promises
        function findAverage(num1, num2) {
            return new Promise((resolve, reject) => {
                // executor (the producing code, The Promise")
                // Change the passing values to see both resolve and reject 
                let avg = (num1 + num2) / 2;

                if (avg >= 60) {
                    // Resolve the promise
                    // We can pass anything to promise()
                    resolve("Passing the course");
                } else {
                    // Reject the promise => using reject() function
                    // (parameter) reject: (reason?: any) => void
                    // We can pass anything to reject()
                    reject("Take another assignment");
                }
            });
        }

        function checkAge(age) {
            return new Promise((resolve, reject) => {
                if (age >= 18) {
                    resolve(`Your age is ${age}, you can buy a lotto ticket`);
                } else {
                    reject("You cannot buy a lotto");
                }
            })
        }


        // Calling these two functions using promises:
        // Note: You can commit calling the function findAverage() below since we have async/await validateInfo()
        /*
        findAverage(90, 79).then(res => {
            console.log(res);
            // Calling the other function checkAge() with return to pass the returned value to the .then()
            return checkAge(20);
        }).then(ageRes => {
            console.log(ageRes);
        }).catch(err => {
            console.log(err);
        });
        */

        // The code above can be simplified by adding async and await
        // NOTE: You can commit the code above after adding async/await to avoid duplicate results
        // async/await work with functions:
        /*
        Notice the code below is shorter and much clear than above. Yes, after removing the comments :-)

        remove async/await from the code below and run the code to clearly see why we add them:
        */

        // NOTE: You can comment this function after adding the new one with try/catch block:
        // Now Applying "async" "await" keywords:
        async function validateInfo() {
            console.log("Calling the two function inside an async/await function");
            // calling our first function findAverage() proceeding with the keyword "await"
            // await will will tell JS to wait until this findAverage function is finished then run the rest of code
            const result = await findAverage(80, 73);
            // So when JavaScript stop at the line await findAverage(), it will leave the function temporary
            // And when findAverage() is finished JS return the response to the variable "result"
            console.log(result);

            const check = await checkAge(15);
            console.log(check);
        }

        validateInfo(); // JS will throw an error if promise failed 

        /*
        One point we need to work around about using async/await function is:
        when we have an error which means the promise is not resolved, JS will throw an error.

        For example if we pass an invalid age for checkAge() in the line: const check = await checkAge(15);
        JS will throw this error: Uncaught (in promise) You cannot buy a lotto
        
        So we need to handle errors and the solution for this is use try/catch block

        We will keep the function validateInfo(); for learning and demonstration
        But we will add a new one that has the same code but with try/catch to handle the errors

        Let's name it "validateHandelInfo()"
        */

        async function validateHandelInfo() {
            try {
                console.log("Calling the two function inside an async/await function");
                // calling our first function findAverage() proceeding with the keyword "await"
                // await will will tell JS to wait until this findAverage function is finished then run the rest of code
                const result = await findAverage(80, 73);
                // So when JavaScript stop at the line await findAverage(), it will leave the function temporary
                // And when findAverage() is finished JS return the response to the variable "result"
                console.log(result);

                const check = await checkAge(10);
                console.log(check);
            } catch (err) {
                console.log(err)
            }
        }

        validateHandelInfo(); // JS will NOT throw an error if promise failed as it's being handled with try/catch

        // Using the same example as we had before with few modifications:
        // You can see the code below has two many lines and deep logic
        const url = "https://anmarjarjees.github.io/json-examples/music-inst.json";

        fetch(url)
            .then(response => {
                // handle the response
                // Instead of just console.log the entire object:
                // console.log(response);

                // Returning the JSON data:
                return response.json();
            }).then(json => {
                console.log(json); // (3) [{…}, {…}, {…}]
            }).catch(error => {
                // handle the error
                /*
                Beside the JS errors, you will see this error message
                */
                console.log("The error that we have is: " + error.message);
                // The error that we have is: TypeError: Failed to fetch
            });

        // We will simplify it with async/await:
        async function getData() {
            // using fetch() but instead of chaining its values with .then(), we will use await:
            /*
            Now await() stops the fetch() from assign the returned value to response,
            until there is a response from the API request to be given.
            Or until the promise from fetch has resolved
            */
            const response = await fetch(url);
            /*
                Now we need to deal with response (the returned result),
                we used .then() in the previous code then json() method

                No need for .then() when we have async function since we have await inside it
                we can use .json() method with another await keyword that will also returns a promise
            */
            const data = await response.json();

            // console.log(data); // (3) [{…}, {…}, {…}]
            // instead of console.log the data,
            // let's return these data so we can use it outside this function
            return data
        }

        // Now to get the returned value of "data" from the function getData() 
        // We can use or chain it with .then() as getData() is just a promise
        getData()
            .then(data => {
                console.log(data);  // (3) [{…}, {…}, {…}]
            })
            // We can continue the chaining with .catch() to catch the errors:
            .catch(err => console.log(`Unable to complete the task: ${err.message}`));
    </script>
</body>

</html>